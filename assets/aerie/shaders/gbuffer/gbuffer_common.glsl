bool isInventory;
float blockDist;
vec3 gamma;

vec2 repeatAndMirrorCoords(vec2 uv) {
	return mix(fract(uv), 1.0 - fract(uv), mod(floor(uv), 2.0));
}

void autogenNormals() {
	#ifdef AUTOGENERATED_NORMALS
		if(frx_modelOriginRegion && frx_fragNormal == vec3(0.0, 0.0, 1.0)) {
			vec2 uv = frx_normalizeMappedUV(frx_texcoord);
			vec2 uv1, uv2, uv3, uv4;
			
			const vec2 sampleOffset = vec2(1.0 / NORMALS_RESOLUTION, 0.0);

			uv1 = uv + sampleOffset.xy;
			uv2 = uv - sampleOffset.xy;
			uv3 = uv + sampleOffset.yx;
			uv4 = uv - sampleOffset.yx;

			vec4 sample1 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv1)), 0);
			vec4 sample2 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv2)), 0);
			vec4 sample3 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv3)), 0);
			vec4 sample4 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv4)), 0);

			// Cursed way to make sure we don't sample invalid pixels.
			sample1 = mix(sample1, sample2, step(sample1.a, 0.0001));
			sample2 = mix(sample2, sample1, step(sample2.a, 0.0001));
			sample3 = mix(sample3, sample4, step(sample3.a, 0.0001));
			sample4 = mix(sample4, sample3, step(sample4.a, 0.0001));

			float height1 = frx_luminance(sample1.rgb * sample1.a);
			float height2 = frx_luminance(sample2.rgb * sample2.a);
			float height3 = frx_luminance(sample3.rgb * sample3.a);
			float height4 = frx_luminance(sample4.rgb * sample4.a);

			float deltaX = (height2 - height1) * NORMALS_STRENGTH;
			float deltaY = (height4 - height3) * NORMALS_STRENGTH;

			frx_fragNormal = normalize(cross(vec3(-2.0, 0.0, deltaX), vec3(0.0, -2.0, deltaY)));
		}
	#endif
}

void transformNormals() {
	#ifndef USE_VERTEX_NORMAL
		// Convert tangent space frx_fragNormal to world space
		mat3 tbn = mat3(
			frx_vertexTangent.xyz, 
			cross(frx_vertexTangent.xyz, frx_vertexNormal.xyz) * frx_vertexTangent.w, 
			frx_vertexNormal.xyz
		);

		frx_fragNormal = tbn * frx_fragNormal;
		if(frx_isHand) {
			// Fix hand normals because they are in view space
			frx_fragNormal = frx_fragNormal * frx_normalModelMatrix;
		}
	#else
		// safeguard
		#define frx_fragNormal (frx_vertexNormal.xyz)
	#endif
}

void lighting(const in float shadowFactor) {
	if(frx_fragColor.a < 0.001) discard;
	frx_fragColor = max(frx_fragColor, vec4(0.0005));

	vec3 lightmap = texture(frxs_lightmap, frx_fragLight.xy).rgb;

	#if defined(TRUE_CAVE_DARKNESS) || defined(TRUE_NIGHT_DARKNESS)
		vec2 trueLight = clamp((frx_fragLight.xy - 1.0 / 16.0) * 16.0 / 14.0, 0.0, 1.0);

		#ifdef TRUE_CAVE_DARKNESS
			lightmap *= mix(max(trueLight.x, trueLight.y), 1.0, float(frx_effectNightVision));
		#endif

		#ifdef TRUE_NIGHT_DARKNESS
			vec3 timeFactors = getTimeOfDayFactors();

			int moonPhase = int(frx_worldDay) % 8;
			float phaseBrightness;

			switch(moonPhase) {
				case 0: {
					phaseBrightness = 1.0;
					break;
				}
				case 1:
				case 7: {
					phaseBrightness = 0.75;
					break;
				}
				case 2:
				case 6: {
					phaseBrightness = 0.5;
					break;
				}
				case 3:
				case 5: {
					phaseBrightness = 0.25;
					break;
				}
				case 4: {
					phaseBrightness = 0.0;
					break;
				}
			}

			lightmap *= mix(1.0, max(phaseBrightness, max(trueLight.x, 1.0 - smoothstep(0.0, 0.5, trueLight.y))), timeFactors.y * (1.0 - frx_effectNightVision));
		#endif
	#endif

	// Diffuse lighting
	#ifdef DIFFUSE_LIGHT
		{
			#ifndef DIFFUSE_SKYLIGHT
				vec3 dir = vec3(-0.1825, 0.9128, 0.3651);
			#else
				vec3 dir = mix(vec3(0.0, 1.0, 0.0), frx_skyLightVector, frx_skyLightTransitionFactor * frx_fragLight.y);
				
				if(isInventory) dir = vec3(0.2, 0.5, 0.8);
			#endif

			float NdotL = (dot(mix(frx_fragNormal, vec3(0.0, 1.0, 0.0), float(frx_matDisableDiffuse)), dir)) * 0.5 + 0.5;
			// NdotL = mix(NdotL, 1.0, float(frx_matDisableDiffuse));
			lightmap *= min(1.0, NdotL * 0.6 + 0.4);
		}
	#endif

	#ifdef SHADOWS
		// Darken ambient light
		lightmap *= 0.65;

		// Apply shadows
		lightmap += 
			0.5 * frx_skyLightColor * 
			frx_skyLightTransitionFactor * frx_fragLight.z * 
			shadowFactor * clamp01(dot(mix(frx_fragNormal, vec3(0.0, 1.0, 0.0), float(frx_matDisableDiffuse)), frx_skyLightVector));
	#endif



	// Handheld lighting
	// To whoever is reading this code in the future, I am sorry.
	#ifdef HANDHELD_LIGHT
		if(!isInventory) {
			#ifdef BLOCKY_HANDHELD_LIGHT
				vec3 wrappedCoord = frx_vertex.xyz - 0.1 * frx_vertexNormal + frx_cameraPos;
				wrappedCoord = floor(wrappedCoord) + 0.5;
				wrappedCoord -= frx_cameraPos;
			#else
				vec3 wrappedCoord = frx_vertex.xyz;
			#endif


			vec3 playerPos = wrappedCoord.xyz + frx_cameraPos - frx_eyePos - vec3(0.0, 1.5, 0.0);

			vec3 playerNormal = normalize(playerPos);

			float lightDist = length(playerPos);
			float NdotL = mix(clamp01(dot(-frx_fragNormal, playerNormal)), 1.0, smoothstep(1.0, 0.0, lightDist));

			float attenuationFactor = smoothstep(
				frx_heldLight.a * 
				#ifndef BLOCKY_HANDHELD_LIGHT
					(7.0 + 3.0 * frx_viewBrightness),
				#else
					(10.0 + 5.0 * frx_viewBrightness),
				#endif
				0.0, 
				lightDist
			);

			#ifndef BLOCKY_HANDHELD_LIGHT
				attenuationFactor *= NdotL;
			#endif

			attenuationFactor = mix(attenuationFactor, 1.0, float(frx_isHand) * frx_heldLight.a);
			
			#ifdef COLORED_HANDHELD_LIGHT
				vec3 heldLightColor = pow(frx_heldLight.rgb * 1.3, vec3(1.5));
			#else
				vec3 heldLightColor = texture(frxs_lightmap, vec2(attenuationFactor * 7.0 / 8.0 + 1.0 / 16.0, frx_fragLight.y)).rgb;
			#endif

			lightmap = mix(lightmap, max(heldLightColor, lightmap), attenuationFactor);//min(lightmap + heldLight, frx_emissiveColor.rgb);
		}
	#endif

	// Apply ambient occlusion
	frx_fragLight.z = mix(pow(frx_fragLight.z, AO_STRENGTH), 1.0, float(frx_matDisableAo));
	lightmap *= frx_fragLight.z;

	// Boost lightmap
	lightmap.rgb *= 1.1;

	// Red hurt effect
	lightmap.gb *= 1.0 - 0.5 * frx_matHurt;

	// Flash effect
	lightmap.rgb += 2.0 * frx_matFlash;

	// Glint effect
	lightmap += frx_matGlint * pow(1.5 * texture(u_glint, frx_normalizeMappedUV(frx_texcoord) + mod(frx_renderSeconds * 0.15, 1000.0)).rgb, vec3(3.0));

	// Apply lightmap
	frx_fragColor.rgb *= mix(lightmap, frx_emissiveColor.rgb + vec3(EMISSION) * float(!isInventory), frx_fragEmissive);
}
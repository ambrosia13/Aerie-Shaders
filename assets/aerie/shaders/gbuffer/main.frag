#include aerie:shaders/lib/includes.glsl 

uniform sampler2D u_glint;

layout(location = 0) out vec4 fragColor;

vec2 repeatAndMirrorCoords(vec2 uv) {
	return mix(fract(uv), 1.0 - fract(uv), mod(floor(uv), 2.0));
}

void frx_pipelineFragment() {
	bool isInventory = frx_isGui && !frx_isHand;
	float blockDist = length(frx_vertex.xyz);
	vec3 gamma = vec3(isInventory ? 1.0 : 2.2);

	#ifdef AUTOGENERATED_NORMALS
		if(frx_modelOriginRegion && frx_fragNormal == vec3(0.0, 0.0, 1.0)) {
			vec2 uv = frx_normalizeMappedUV(frx_texcoord);
			vec2 uv1, uv2, uv3, uv4;
			
			const vec2 sampleOffset = vec2(1.0 / NORMALS_RESOLUTION, 0.0);

			uv1 = uv + sampleOffset.xy;
			uv2 = uv - sampleOffset.xy;
			uv3 = uv + sampleOffset.yx;
			uv4 = uv - sampleOffset.yx;

			vec4 sample1 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv1)), 0);
			vec4 sample2 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv2)), 0);
			vec4 sample3 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv3)), 0);
			vec4 sample4 = textureLod(frxs_baseColor, frx_mapNormalizedUV(repeatAndMirrorCoords(uv4)), 0);

			// Cursed way to make sure we don't sample invalid pixels.
			sample1 = mix(sample1, sample2, step(sample1.a, 0.0001));
			sample2 = mix(sample2, sample1, step(sample2.a, 0.0001));
			sample3 = mix(sample3, sample4, step(sample3.a, 0.0001));
			sample4 = mix(sample4, sample3, step(sample4.a, 0.0001));

			float height1 = frx_luminance(sample1.rgb * sample1.a);
			float height2 = frx_luminance(sample2.rgb * sample2.a);
			float height3 = frx_luminance(sample3.rgb * sample3.a);
			float height4 = frx_luminance(sample4.rgb * sample4.a);

			float deltaX = (height2 - height1) * NORMALS_STRENGTH;
			float deltaY = (height4 - height3) * NORMALS_STRENGTH;

			frx_fragNormal = normalize(cross(vec3(-2.0, 0.0, deltaX), vec3(0.0, -2.0, deltaY)));
		}
	#endif

	#ifndef USE_VERTEX_NORMAL
		// Convert tangent space frx_fragNormal to world space
		mat3 tbn = mat3(
			frx_vertexTangent.xyz, 
			cross(frx_vertexTangent.xyz, frx_vertexNormal.xyz) * frx_vertexTangent.w, 
			frx_vertexNormal.xyz
		);

		frx_fragNormal = tbn * frx_fragNormal;
		if(frx_isHand) {
			// Fix hand normals because they are in view space
			frx_fragNormal = frx_fragNormal * frx_normalModelMatrix;
		}
	#else
		// safeguard
		#define frx_fragNormal (frx_vertexNormal.xyz)
	#endif

	vec4 color = frx_fragColor;
	if(color.a < 0.001) discard;
	color = max(color, vec4(0.0005));

	vec3 lightmap = texture(frxs_lightmap, frx_fragLight.xy).rgb;

	#if defined(TRUE_CAVE_DARKNESS) || defined(TRUE_NIGHT_DARKNESS)
		vec2 trueLight = clamp((frx_fragLight.xy - 1.0 / 16.0) * 16.0 / 14.0, 0.0, 1.0);

		#ifdef TRUE_CAVE_DARKNESS
			lightmap *= mix(max(trueLight.x, trueLight.y), 1.0, float(frx_effectNightVision));
		#endif

		#ifdef TRUE_NIGHT_DARKNESS
			vec3 timeFactors = getTimeOfDayFactors();

			int moonPhase = int(frx_worldDay) % 8;
			float phaseBrightness;

			switch(moonPhase) {
				case 0: {
					phaseBrightness = 1.0;
					break;
				}
				case 1:
				case 7: {
					phaseBrightness = 0.75;
					break;
				}
				case 2:
				case 6: {
					phaseBrightness = 0.5;
					break;
				}
				case 3:
				case 5: {
					phaseBrightness = 0.25;
					break;
				}
				case 4: {
					phaseBrightness = 0.0;
					break;
				}
			}

			lightmap *= mix(1.0, max(phaseBrightness, max(trueLight.x, 1.0 - smoothstep(0.0, 0.5, trueLight.y))), timeFactors.y * (1.0 - frx_effectNightVision));
		#endif
	#endif

	// Diffuse lighting
	#ifdef DIFFUSE_LIGHT
		#ifndef DIFFUSE_SKYLIGHT
			vec3 dir = vec3(-0.1825, 0.9128, 0.3651);
		#else
			vec3 dir = frx_skyLightVector;
		#endif

		float NdotL = clamp01(dot(mix(frx_fragNormal, vec3(0.0, 1.0, 0.0), float(frx_matDisableDiffuse)), dir));
		// NdotL = mix(NdotL, 1.0, float(frx_matDisableDiffuse));
		lightmap *= min(1.0, NdotL * 0.6 + 0.6);
	#endif

	// Handheld lighting
	#ifdef HANDHELD_LIGHT
		if(!isInventory) {
			vec3 playerPos = frx_vertex.xyz + frx_cameraPos - frx_eyePos - vec3(0.0, 1.5, 0.0);
			vec3 playerNormal = normalize(playerPos);

			float lightDist = length(playerPos);
			NdotL = mix(clamp01(dot(-frx_fragNormal, playerNormal)), 1.0, smoothstep(1.0, 0.0, lightDist));

			float attenuationFactor = smoothstep(frx_heldLight.a * 10.0, 0.0, lightDist) * NdotL;
			
			vec3 heldLight = frx_heldLight.rgb * attenuationFactor;
			lightmap = mix(lightmap, max(frx_heldLight.rgb * 1.3, lightmap), attenuationFactor);//min(lightmap + heldLight, frx_emissiveColor.rgb);
		}
	#endif

	// Apply ambient occlusion
	frx_fragLight.z = mix(pow(frx_fragLight.z, AO_STRENGTH), 1.0, float(frx_matDisableAo));
	lightmap *= frx_fragLight.z;

	// Boost lightmap
	lightmap.rgb *= 1.1;

	// Red hurt effect
	lightmap.gb *= 1.0 - 0.5 * frx_matHurt;

	// Flash effect
	lightmap.rgb += 2.0 * frx_matFlash;

	// Glint effect
	lightmap += frx_matGlint * pow(1.5 * texture(u_glint, frx_normalizeMappedUV(frx_texcoord) + mod(frx_renderSeconds * 0.15, 1000.0)).rgb, vec3(3.0));

	// Apply lightmap
	color.rgb *= mix(lightmap, frx_emissiveColor.rgb + vec3(EMISSION) * float(!isInventory), frx_fragEmissive);

	// Transform the color into gamma space
	if(!isInventory) color.rgb = pow(color.rgb, vec3(2.2));

	fragColor = color;
	gl_FragDepth = gl_FragCoord.z;
}